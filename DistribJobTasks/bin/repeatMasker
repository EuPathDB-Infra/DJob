#!@perl@

## takes in a library file, runs cross_match to block repeated sequences (Human)
## and writes back out a blocked library to STDOUT

## modified to also trim the ends that end in NNNN so will not dangle...

## Brian Brunk 8/12/98

use strict;
use FileHandle;
use Getopt::Long;

print STDERR "Incoming cmdline: repeatMasker @ARGV\n";

my($rmOptions,$inFile,$outFile,$errFile,$mod,$modValue,$rmPath,$trimDangling,
  $dangleLength,$dangleMax);
&GetOptions('rmPath=s' => \$rmPath,
            'seqFile=s' => \$inFile,
            'errorFile=s' => \$errFile,
            'outFile=s' => \$outFile,
            'mod=i' => \$mod, 'modValue=i' => \$modValue,
            'trimDangling!' => \$trimDangling,
	    'dangleMax=i' => \$dangleMax);


##usage etc
if (!$inFile || !$outFile ) {
	print STDERR "Usage: blockLibraryWithRM --inFile <inputSequenceFile> --outFile <outputSequenceFile> --errorFile <errorFilename> --mod <number of logical parts to split file into> --modValue <mod value for this run>  --trimDangling <boolean: trim bases from end if dangling off of masked seq> --dangleMax <this number or less of bases will be trimmed> -- <RepeatMasker options as they appear on the command line>\n\n";
	system("$rmPath/RepeatMasker");
	exit 1;
}

$rmOptions = join(" ",@ARGV);

my $tmpFile = "tmpBlock.$$";

my $errorFile = $errFile ? $errFile : ">blockLib_error.log";
	
open(ERR, ">$errorFile");
select ERR; $| = 1;
select STDOUT;
$| = 1;

my %fin;
if(-e "$outFile"){  #3restarting...
  open(R, "$outFile");
  while(<R>){
    if(/^\>(\S+)/){
      $fin{$1} = 1;
    }
  }
  close R;
}
  
open(OUT, ">$outFile");

##command for RepeatMasker

my $RepMaskCmd = "RepeatMasker $rmOptions $tmpFile";
#print STDERR "RepeatMasker command:\n  $RepMaskCmd\n";


my $tmpSeq = "";
my $miniLib = "";
my $countNumSeqs = 0;
my $ctLength = 0;
my $countPart = 0;

$mod = $mod ? $mod : 1;
$modValue = $modValue ? $modValue : 0;

if($inFile =~ /gz$/){
	open(F,"gunzip -c $inFile |");
}else{
	open(F,"$inFile") || die "file $inFile not found\n";
}
my $ct = 0;
my $doThis = 0;
while (<F>) {
  if (/^\>(\S+)/) {
    if($ct % $mod == $modValue && !$fin{$1}){
      $miniLib .= $tmpSeq;
      $countNumSeqs++;
      $tmpSeq = $_;
      $countPart = 0;
      $doThis = 1;
    }else{
      $doThis = 0;
    }
    $ct++;
  } elsif($doThis) {
    
    $tmpSeq .= $_;  
    $ctLength += length($_) - 1;
    $countPart += length($_) - 1;
    if ($ctLength >= 98000 && $countNumSeqs >= 1) { ##if don't yet have a single sequence.. 
      &processSet($miniLib,$ctLength); ##leaves current $tmpSeq intact for next round
      $countNumSeqs = 0;
      $miniLib = "";						##reset for next set of seqs
      $ctLength = $countPart;		##sets library to count contained in current sequence..
    }
  }
}
close F;
$miniLib .= $tmpSeq;
&processSet($miniLib,$ctLength); ##processes last set

system ("rm $tmpFile*");
close ERR;
close OUT;

##subroutine that does the processing
sub processSet {
	my $miniLib = shift;
	my $ctLength = shift;
	#	system ("rm $tmpFile.*");
  open(S, ">$tmpFile");
  print S $miniLib;
  close S;
  
#	print STDERR "Processing miniLib: length = $ctLength\n";
	
	##run RepeatMasker##
	unlink "$tmpFile.masked";
	my $cmd = "$rmPath/$RepMaskCmd >& rm.stdout";
        print STDERR "Command:  $cmd\n";
	my $status = system($cmd) >> 8;
	die "repeatmasker returned status $status running $cmd" if $status;
	die "repeatmasker ($cmd) did not create $tmpFile.masked" unless -e "$tmpFile.masked";

  ##generate better sequence....
  my @qmSeq = &readSeqFileToArray("$tmpFile.masked");
  foreach my $seq (@qmSeq) {
    $seq->[1] =~ s/\s+//g;			##gets rid of spaces and newlines

    my $sequence = $trimDangling ? &trimDanglingNNN($seq->[1]) : $seq->[1];

    my $tmpSeq = $sequence;
    $tmpSeq =~ s/N//g;

    if (length($tmpSeq) > 50) {
      print OUT "$seq->[0]", &breakSequence($sequence);
    } else {
	my $l = length($tmpSeq);
	my $def = $seq->[0];
	chomp $def;
      print ERR "$def [TOO SHORT: $l]\n";
    }
  }
}

sub breakSequence {
  my($seq) = @_;
  ##just in case there are returns...
  $seq =~ s/\s//g;
  my $new = "";
  for (my $i = 0;$i<length($seq);$i+=80) {
    $new .= substr($seq,$i,80) . "\n";
  }
  return $new;
}

sub readSeqFileToArray{					##read into array or arrays
  my($file) = @_;
  my @seq;
  my $c = 0-1;
	my $fh = FileHandle->new($file);
  open(TF, "$file");
  while (<TF>) {
    if (/^\>/) {
      $c++;
      $seq[$c]->[0] = $_;				##makes key the entire defline...
    } else {
      $seq[$c]->[1] .= $_; 
    }
  }
  close TF;
  return @seq;
}

sub trimDanglingNNN {
  my ($seq) = @_;


  # forward strand
  my $mightNeedTrimming = 1;
  while($mightNeedTrimming) {
    ($seq, $mightNeedTrimming) = &trimDanglingNNN_sub($seq);
  }

  # reverse strand (only bother if there are and NNNs left)
  if ($seq =~ /N/) {
    my $rev = &reverseComplementSequence($seq);
    $mightNeedTrimming = 1;
    while($mightNeedTrimming) {
      ($rev, $mightNeedTrimming) = &trimDanglingNNN_sub($rev);
    }
    # don't bother unreversing if not changed
    if (length($rev) != length($seq)) {
      $seq = &reverseComplementSequence($rev);
    }
  }
  return $seq;
}



sub trimDanglingNNN_sub {
  my($seq) = @_;

  my $trimmed; 
  if ($seq =~ /^(.*?)NNNNNNNNNN+(.*?)$/) {
    if (length($1) <= $dangleMax) {
      $seq = $2;
      $trimmed = 1;
    }
  }
  return ($seq, $trimmed);
}

sub reverseComplementSequence{ ##for reverseComplementing sequences
  my($seq) = @_;
  $seq =~ s/\s//g;
  my $revcompseq = "";
  my $revseq = reverse $seq;
  my @revseq = split('', $revseq);
  foreach my $nuc (@revseq) {
    $revcompseq .= &compNuc($nuc);
  }
  return $revcompseq;
}

sub compNuc{
  my($nuc) = @_;
  if ($nuc =~ /A/i) {
    return "T";
  } elsif ($nuc =~ /T/i) {
    return "A";
  } elsif ($nuc =~ /C/i) {
    return "G";
  } elsif ($nuc =~ /G/i) {
    return "C";
  }
  return $nuc;
}

